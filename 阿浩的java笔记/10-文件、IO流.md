### 一，文件

#### 1.1 File类的概述

> **File类定义**
>
>  1.File类主要是JAVA为文件这块的操作(如删除、新增等)而设计的相关类。
>
>  2.File类的包名是java.io，其实现了Serializable, Comparable两大接口以便于其对象可序列化和比较。
>
>  3.File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。File 类的实例是不可变的；也就是说，一旦创建，File 对象表示的抽象路径名将永不改变。
>
>  4.File类代表一个特定的文件或者目录（文件夹），并提供了若干方法对该文件或目录进行操作。

#### 1.2 File类的构造函数

> 1. new File(String path)
>
>    ```java
>    public class Test2{
>     public static void main(String[] args){
>             File file=new File("xxx");
>             System.out.println(file.getPath());  //路径结果就是xxx
>        }
>    }
>    ```
>
> 2. new File(String parent，String child)
>
>    ```java
>    public class Test2{
>     /*
>     若子路径child为Null，会抛出NullPointerException空异常错误
>     当父路径为Null时，会以子路径child作为绝对路径创建实例，等同于调用第一个File(String child )效果一样
>     */
>     public static void main(String[] args){
>             String parent=null;
>             File file=new File(parent,"xxx");
>             System.out.println(file.getPath());  //路径结果就是xxx
>        }
>    }
>    ```
>
>    
>
> 3. new File(File parent，String child)
>
>    ```java
>    public class Test2{ 
>        public static void main(String[] args){
>            String parent = "E:/test";
>            File parentFile= new File(parent);
>            String child = "E:/test/1.txt";
>            File file = new File(parentFile, child);
>            System.out.println(file.getPath()); // 路径结果就是E:\test\E:\test\1.txt
>        }
>    }
>    ```
>
>    

#### 1.3 File类的常用方法

> 创建删除
>
> 1. createNewFile()  //创建指定文件
> 2. mkdir()  //创建指定文件夹
> 3. mkdirs()  //能够创建多层文件夹
> 4. delete()  //删除指定文件/文件夹对象
> 5. deleteOnExit()  //当java虚拟机对此进程结束运行时，才执行此条语句，即删除指令

> 判断
>
> 1. isFile()  判断是否是文件 
>
> 2. isDirectory()  判断是否是文件夹
>
> 3. exists()  判断文件/文件夹是否存在
>
> 4. isAbsolute()：判断当前文件对象指向的文件是否是绝对地址的，
>
>    ​	绝对路径：从盘符开始、
>
>    ​	相对路径：相对与项目的根目录开始
>
> 5. canRead()  如果指定的文件存在的路径名和文件允许应用程序读取，此方法返回布尔值true。
>
> 6. canWrite()  是否可以写入由抽象路径名表示的文件。如果存在抽象文件路径并且允许应用程序写入文件，则该函数返回true。
>
> 注：判断是否是文件或者文件夹，如果不存在都返回false

> 获取
>
> 1. length()：返回文件大小，单位是字节，空文件夹则是0
>
> 2. getParent()：获取父目录的绝对路径
>
> 3. getParentFile()：返回父目录的对象
>
> 4. getPath()：获取this在创建时所传入的路径
>
> 5. getAbsolutePath()：获取绝对路径  
>
>    ```java
>    File file = new File("a.txt");
>    System.out.println(file.getPath());
>    System.out.println(file.getAbsolutePath());
>    
>    /*
>    输出结果:
>    a.txt
>    E:\2023_project\a.txt
>    */
>    ```
>
>    
>
> 6. getAbsoluteFile()：返回以此路径所创建出的File对象
>
> 7. getName()：获取**文件/文件夹**名

> 文件的遍历：
>
> 1. list()：返回指定目录中所有文件、文件夹的名字组成的字符串数组
>
> 2. listFiles()：返回指定目录中所有文件、文件夹对象组成的数组
>
>    ```java
>    File f2 = new File("C:\\mine\\下载\\迅雷");
>    File[] files = f2.listFiles();
>    for(File file : files){
>        System.out.println(file);
>    }
>    ```
>
> 3. list(FilenameFilter filter)：返回指定目录中符合要求的所有文件、文件夹的名字组成的字符串数组
>
> 4. listFiles(FilenameFilter filter)：返回指定目录中符合要求的所有文件、文件夹对象组成的数组
>
>    ```java
>    File f = new File("C:\\Users\\86151\\Desktop\\Java2106\\笔记");
>    File[] files = f.listFiles(new FilenameFilter(){
>        /*
>        参数：
>        1.dir：当前遍历的文件夹对象
>        2.name：当前文件夹中所有文件/文件夹的名字
>        */
>        @Override
>        public boolean accept(File dir, String name) {
>            File f = new File(dir,name);
>            long len = f.length() / 1024;
>            return len >= 10 && len <= 15;
>        }
>    });
>    System.out.println(files.length);
>    for(File file : files ){
>        System.out.println(file);
>    }
>    ```
>
> 5. listFiles(FileFilter filter)：返回指定目录中符合要求的所有文件、文件夹对象组成的数组
>
>    ```java
>    File f = new File("C:\\Users\\86151\\Desktop\\Java2106\\笔记");
>    File[] files = f.listFiles(new FileFilter(){
>        // 参数f：当前目录下文件/文件夹的文件对象
>        @Override
>        public boolean accept(File f) {
>            return f.isFile() && f.length() // 1024 < 10;
>        }
>    });
>    System.out.println(files.length);
>    for(File file : files){
>        System.out.println(file);
>    }
>    ```

> 递归：一个方法直接或间接的调用自身
>
> 核心思想：把一个大型复杂的问题转换成一个与原问题相似规模较小的问题
>
> 好处：大大地减少了程序的代码量
>
> 弊端：资源消耗较大，效率较低
>
> ```java
> // 文件的递归，获取指定目录下的所有文件
> public void searchFile(File dir){
>         File[] files = dir.listFiles();
>         for(File file : files){
>             if(file.isFile()){
>                 System.out.println(file);
>             }else{
>                 searchFile(file);
>             }
>         }
> }
> ```

### 二，IO流

#### 2.1 概念

> IO流：我们将数据的传递看成数据的流动，使用i（input）表示输入，使用o（output）表示输出来描述数据的流向
>
> IO流的分类：
>
> 1. 根据流向
>    1. 输入流：外部 -> 内存
>    2. 输出流 ：内存 -> 外部
> 2. 根据文件类型
>    1. 字节流：操作任何类型的文件
>    2. 字符流：操作文本文件
>
> IO流的四个顶层父类：都是抽象类
>
> 1. 字节输入流：InputStream
> 2. 字节输出流：OutputStream
> 3. 字符输入流：Reader            
> 4. 字符输出流：Writer

#### 2.2 FileOutputStream 文件字节输出流

> 构造函数：
>
> 1. new FileOutputStream(String path)
> 2. new FileOutputStream(String path，boolean append)  //后面的booean值表示是否可追加值
> 3. new FileOutputStream(File f)
> 4. new FileOutputStream(File ，boolean append)
>
> 注：如果使用的构造函数没有boolean参数或者boolean参数是false，都会重新创建出这个文件，如果使用的构造函数中的boolean参数是true，那么不会重新创建出这个文件

> 常用方法：
>
> 1. write(int b)
> 2. write(byte[] b)322
> 3. write(byte[] b，int offset ，int len)
> 4. flush()：将缓冲区中的内容刷新到目标地址中
> 5. close()：释放资源
>
> 注：
>
> 1. close()也会将缓冲区中的内容刷新到目标地址，但是它与flush()的区别是，flush()只是将缓冲区中的内容刷新到目标地址中，流的资源并没有释放，所以在flush()之后可以继续使用流；close()方法还释放了所有流的资源，所在在close()之后不能在继续使用流，继续使用流会发生`IOException`；
> 2. 字节流不需要手动调用flush()，因为字节流会自动将内容刷新到目标地址

#### 2.3 FileInputStream 文件字节输入流

>构造函数
>
>1. new FileInputStream(String path)
>2. new FileInputStream(File f)

> 常用方法：
>
> 1. read()：读取一个字符，返回该字符对应的十进制数，返回-1表示读完了
>
>    ```java
>    FileInputStream fis1 = new FileInputStream("C:\\Users\\Administrator\\Desktop\\0406\\演示用\\a.txt");
>    int t;
>    String s = "";
>    while((t = fis1.read()) != -1){
>        s += (char)t;
>    }
>    System.out.println(s);
>    ```
>
>    
>
> 2. read(byte[] b)：读取若干字符，将读取到的字符对应的十进制数保存在字节数组中，返回读取到的有效个数，返回-1表示读完了
>
> 3. read(byte[] b，int off，int len)
>
>    ```java
>    FileInputStream fis = new FileInputStream("C:\\Users\\Administrator\\Desktop\\0406\\演示用\\b.txt");
>    byte[] bs = new byte[6];
>    int len;
>    String s = "";
>    while((len = fis.read(bs)) != -1){
>        s += new String(bs,0,len);
>    }
>    System.out.println(s);
>    ```
>
>    
>
> 4. close()：释放资源

> ​	文件的剪切
>
> ```java
> public static void cut() throws Exception{
>  String orginal = "E:\\软件\\八爪鱼\\Octopus Setup 8.5.1 - 副本.exe";
>  File f = new File(orginal);
> 
>  String target = "C:\\Users\\Administrator\\Desktop\\0407\\测试\\八爪鱼.exe";
> 
>  FileOutputStream fos = new FileOutputStream(target);
>  FileInputStream fis = new FileInputStream(orginal);
> 
>  byte[] bs = new byte[1024 * 1024];
>  int len = 0;
>  while((len = fis.read(bs)) != -1){
>      fos.write(bs,0,len);
>  }
>  f.deleteOnExit();//无论在释放资源前后执行此条语句,删除功能照常进行
>  //f.delet();在释放资源前执行此条语句,功能不生效
>  fis.close();
>  fos.close();
> }
> ```
>

#### 2.4 FileWriter 文件字符输出流

> 构造函数
>
> 1. new FileWriter(File f)
> 2. new FileWriter(File f，boolean append)
> 3. new FileWriter(String path)
> 4. new FileWriter(String path，boolean append)
>
> 常用方法
>
> 1. write(String s)
> 2. write(char[] chs)
> 3. write(char[] chs，int off，int len)
> 4. write(String s，int off，int len)
> 5. write(int c)
> 6. close()：释放资源
> 7. flush()：使用字符流在输出时，会将数据先写到缓冲区中，我们需要调用flush()方法，才能将缓冲区中的数据刷新到目标地址
>
> 注：flush()和close()都可以刷新缓冲区，区别是flush()之后流还可以继续使用，close()之后不能再使用这个流

#### 2.5 FileReader 文件字符输入流

> 构造函数
>
> 1. new FileReader(File f)
> 2. new FileReader(String path)
>
> 常用方法
>
> 1. read()：读取一个字符，返回该字符对应的十进制数，返回-1表示读完了
>
>    ```java
>    FileInputStream fis1 = new FileInputStream("C:\\Users\\Administrator\\Desktop\\0406\\演示用\\a.txt");
>    int t;
>    String s = "";
>    while((t = fis1.read()) != -1){
>        s += (char)t;
>    }
>    System.out.println(s);
>    ```
>
>    
>
> 2. read(char[] chs)：读取若干字符，将读取到的字符对应的十进制数保存在字节数组中，返回读取到的有效个数，返回-1表示读完了
>
>    ```java
>    FileInputStream fis = new FileInputStream("C:\\Users\\Administrator\\Desktop\\0406\\演示用\\b.txt");
>    byte[] bs = new byte[6];
>    int len;
>    String s = "";
>    while((len = fis.read(bs)) != -1){
>        s += new String(bs,0,len);
>    }
>    System.out.println(s);
>    ```
>
>    
>
> 3. read(char[] chs，int off，int len)

#### 2.6 缓冲流

> 也称为高效流，它是对四个文件流的加强，它的读写速度更快
>
> 1. BufferedOutputStream：字节缓冲输出流
>    - 常用方法：同 FileOutputStream
> 2. BufferedInputStream：字节缓冲输入流
>    - 常用方法：同 FileInputStream
> 3. BufferedReader：字符缓冲输入流
>    - 常用方法：同 FileReader
>    - 特有方法：readLine()：读取一行
> 4. BufferedWriter：字符缓冲输出流
>    - 常用方法：同 FileWriter
>    - 特有方法：newLine()：换行
>
> 构造函数
>
> 1. new BufferedOutputStream(OutputStream os)
> 2. new BufferedInputStream(InputStream is)
> 3. new BufferedReader(Reader r)
> 4. new BufferedWriter(Writer w)

#### 2.7 对象流

> 在Java中允许将一个对象存储到文件中，也可以将一个文件中的对象解析到程序中，这种操作就要使用对象流来完成。
>
> 序列化：将一个对象存储到文件中
>
> 反序列化：将一个文件中的对象解析到程序中
>
> 注：
>
> 1. 要被序列化的对象所在的类，必须实现序列化接口`Serializable`，该接口中没有任何方法，因为它是一个标志型的接口，标志当前的类允许被序列化
> 2. 序列化前后的类必须保证没有变化
>
> **ObjectOutputStream**
>
> 构造函数：new ObjectOutputStream(OutputStream os)
>
> **ObjectInputStream**
>
> 构造函数：new ObjectInputStream(InputStream is)
>
> ```java
> FileOutputStream fos = new FileOutputStream("C:\\Users\\Administrator\\Desktop\\0407\\stu.txt");
> Stu s = new Stu("zs",20);
> ObjectOutputStream oos  = new ObjectOutputStream(fos);
> oos.writeObject(s);
> 
> FileInputStream fis = new FileInputStream("C:\\Users\\Administrator\\Desktop\\0407\\stu.txt");
> ObjectInputStream ois = new ObjectInputStream(fis);
> Stu o = (Stu)ois.readObject();
> System.out.println(o.toString());
> ```
>
> 关键字：`transient`短暂的、瞬间的、瞬时的、瞬态的，在对象被序列化时，被`transient`修改的属性，不会被序列化

#### 2.8 Properties 属性集

> 它本质上是一个Map，元素是以键值对的方式进行存储的，但是它的键和值只能是字符串类型的。
>
> Properties用于编写配置文件
>
> Properties文件编写的注意点：
>
> 1. 每条配置信息必须独占一行
>
> 2. 每条配置信息的都要由键和值组成
>
> 3. 键值对的格式如下：
>
>    ```properties
>    key=value
>    key:value
>    key value
>    ```

> 构造函数：new Properties()
>
> 常用方法：
>
> 1. load(Reader r)
> 2. load(InputStream is)
> 3. getProperty(String key)

#### 2.9 文件夹的复制

> 
>
> ```java
> package file;
> 
> import java.io.*;
> 
> public class Demo4 {
>     /*
>     5.将C盘中的a.txt全部剪切到D盘中
>     已升级，可复制文件夹和文件
>     */
>     public static void main(String[] args) throws IOException {
>         File fileStart = new File("E:\\java课程及工具\\课程\\Java_QF\\软件\\java编程工具\\ideaIU-2021.3.3.exe");
>         File fileEnd = new File("C:\\Users\\86178\\Desktop\\测试");
>         Long start = System.currentTimeMillis();
>         creationDirectory(fileStart , fileEnd);
>         Long end = System.currentTimeMillis();
>         System.out.println((end - start)/1000);
>     }
> 
>     //先保证所有的文件夹会通过递归的方式创建
>     private static void creationDirectory(File fileStart, File fileEnd) throws IOException {
>         if (fileStart.isDirectory()){
>             /*
>             使用新的file对象，避免地址传递导致数据异常
>             获取当前文件夹的绝对路径，并创建
>             */
>             File directoryEnd = new File(fileEnd , fileStart.getName());
>             directoryEnd.mkdir();
>             //获取文件夹内的所有文件对象，并判断是否有文件夹
>             File[] files = fileStart.listFiles();
>             for (File file : files) {
>                 File directoryName = new File(fileStart.getAbsolutePath() , file.getName());
>                 if (file.isDirectory()){
>                     creationDirectory(directoryName , directoryEnd);
>                 }else{
>                     cutFile(directoryName , directoryEnd);
>                 }
>             }
>         }else{
>             cutFile(fileStart , fileEnd);
>         }
>     }
> 
>     //文件的IO字节流
>     private static void cutFile(File fileStart, File fileEnd) throws IOException {
>         fileEnd = new File(fileEnd , fileStart.getName());
>         OutputStream ops = new FileOutputStream(fileEnd);
>         InputStream ips = new FileInputStream(fileStart);
> //        copyFile_1(ops , ips);
>         copyFile_2(ops , ips);
>         ops.close();
>         ips.close();
>     }
> 
>     //高效流
>     private static void copyFile_2(OutputStream ops, InputStream ips) throws IOException {
>         BufferedInputStream bis = new BufferedInputStream(ips);
>         BufferedOutputStream bos = new BufferedOutputStream(ops);
>         byte[] bs = new byte[1024];
>         int len;
>         while ((len = bis.read(bs)) != -1){
>             bos.write(bs , 0 , len);
>         }
>         bos.close();
>         bis.close();
>     }
> 
>     //将复制的方法单独封装出来
>     private static void copyFile_1(OutputStream ops, InputStream ips) throws IOException {
>         byte[] bs = new byte[1024];
>         int len;
>         while ((len = ips.read(bs)) != -1){
>             ops.write(bs , 0 , len);
>         }
>     }
> }
> ```
>

























