###  一，集合的概念

> 用来存储数据的容器
>
> 数组的缺点：
>
> 1. 只能存储一种类型
> 2. 数组的长度固定
>
> 集合的特点：
>
> 1. 集合可以存储任意类型的数据
>
>    注：
>
>    1. 集合存储的默认类型是Object
>
>    2. 但是一般建议在创建集合时去指定集合的泛型，集合的泛型也就是基本中操作元素的类型
>
>       ```java
>       ArrayList<指定的类型> list = new ArrayList<指定的类型>();
>       注：如果要存储的是基本类型的值，泛型只能写基本类型的包装类
>       ```
>
> 2. 集合的长度是可变的

> 集合分为两部分：
>
> 1. 单列集合 Collection
> 2. 双列集合 Map

### 二，Collection

> Collection是一个接口，提供了集合的基本方法
>
> Collection有两个重要的子接口
>
> 1. List
>
>    实现类：ArrayList、LinkedList、Vector
>
> 2. Set
>
>    实现类：HashSet、TreeSet、LinkedHashSet
>
> Collection的特点：
>
> 1. Collection的实现类可以存储任意个元素，存储元素的类型默认都是Object
> 2. 子接口List有序可重复
> 3. 子接口Set不可重复，有些实现类有序，有些实现类无序（存取顺序不一致）

> Collection接口的常用方法：
>
> 1. add()   增加内容
> 2. remove()   删除指定内容（包含多个）
> 3. size()   返回大小
> 4. contains()    查找，返回boolean值
> 5. clear()   清空集合
> 6. isEmpty()   判断集合是否为空
> 7. addAll()   在this集合末尾加上()里的内容
> 8. containsAll()   this.containsAll(?) 判断内容是否包含?
> 9. removeAll()   删除（）内集合中的内容，如果集合和集合二内容相同，但大小不同或相同，此方法将this删除为空内容
> 10. retainAll()   方法用于保留 arraylist 中在指定集合中也存在的那些元素，也就是删除指定集合中不存在的那些元素。

> Collection接口的遍历：
>
> 1. 增强for循环
>
>    ```java
>    Collection<String> col = new ArrayList<>();
>    col.add("王五");
>    col.add("李四");
>    col.add("张三");
>    col.add("李四");
>    for(String s : col){
>        System.out.println(s);
>    }
>    ```
>
>    注：Collection的任何一个实现类都可以使用foreach进行遍历
>
> 2. 普通for循环
>
>    ```java
>    ArrayList<String> col = new ArrayList<>();
>    col.add("王五");
>    col.add("李四");
>    col.add("张三");
>    col.add("李四");
>    for(int i = 0;i <= col.size() - 1; i++){
>        System.out.println(col.get(i));
>    }
>    ```
>
>    注：只有Collection中List及其实现类才可以使用普通for循环进行遍历
>
> 3. 使用迭代器Iterator
>
>    Collection接口继承了Iterable接口，在Iterable接口中提供了一个iterator()的方法用于获取迭代器对象；迭代器只用于遍历集合，它本身不存储集合；
>
>    Iterator中提供了两个方法，用于遍历元素
>
>    1. hasNext()：判断是否有下一个可以获取的元素
>
>    2. next()：将指针向下移动，并获取指向的元素
>
>       注：如果没有下一个可获取的元素，还调用了next()会发生`NoSuchElementException`没有这个元素异常
>
>    ```java
>    Collection<String> col = new ArrayList<>();
>    col.add("李四");
>    col.add("王五");
>    col.add("张三");
>    col.add("李四");
>    Iterator<String> it = col.iterator();
>    while(it.hasNext()){
>        System.out.println(it.next());
>    }
>    ```
>
>    注：
>
>    1. 增强for循环能替换迭代器的写法
>    2. 迭代器迭代完毕后，不能再继续迭代，因为已经到达了末尾，如果还要迭代需要获取新的迭代器对象

### 三，List

> List是有序可重复的集合，每个元素都有各自的索引。
>
> **常用方法：**
>
> 1. add(int index，Object o)   在指定下标插入集合中的内容
> 2. remove(int index)   删除指定下标内容
> 3. set(int index ，Object o) 	修改指定下标内容
> 4. get(int index)   获取指定下标的内容
> 5. indexOf(Object o) 返回从左到右第一个元素的下标
> 6. lastIndextOf(Object o) 返回 从末尾往前搜索的第一个元素的下标
> 7. subList(int fromIndex，int toIndex)：利用list中索引位置重新生成一个新的list（截取集合)
> 8. .toArray()   .将集合转换为数组

> **ArrayList底层结构：**
>
> 1. ArrayList的底层是数组，ArrayList中维护了一个Object类型的数组`elementData`
> 2. 创建对象时，如果使用的是无参构造函数来创建，那么`elementData`是一个长度为0的空数组
> 3. 在添加元素时，会先判断是否需要扩容，第一次添加时，`elementData`的长度会扩容到10，在继续添加元素时，如果长度没有超过最大长度，则直接添加，如果超过了最大长度，会根据原始长度的1.5倍进行扩容
> 4. 创建对象时，如果使用的是重载构造函数来创建，那么`elementData`是一个指定长度的内容都为null的数组。

> **LinkedList底层结构：**
>
> 1. LinkedList的底层是双向链表
>
> 2. LinkedList中定义了两个属性first和last分别指向集合的首节点和尾节点
>
> 3. 每个节点都是一个Node对象，Node中有prev属性指向上一个**节点对象**，有next属性指向下一个**节点对象**，有item属性保存存储的数据
>
>    |            | 底层     | 增删的效率 | 改查的效率 |
>    | ---------- | -------- | ---------- | ---------- |
>    | ArrayList  | 数组     | 较低       | 较高       |
>    | LinkedList | 双向链表 | 较高       | 较低       |
>    
>    ![](一。Java基础.assets\屏幕截图 2023-12-01 220757.png)
>
> 注：LinkedList中除了有List的共性方法之外，还有一些专门用于操作首元素和尾元素的方法
>
> 1. addFirst()   将指定元素插入此列表的开头。
> 2. addLast()   将指定元素插入此列表的末尾。
> 3. remove()   获取并移除此列表的头（第一个元素）。
> 4. removeFirst()  从此列表中删除并返回第一个元素
> 5. removeLast()   从此列表中删除并返回最后一个元素
> 6. getFirst()   返回此列表的第一个元素
> 7. peekFirst()   获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。
> 8. pollFirst()   检索并删除此列表的第一个元素，如果此列表为空，则返回 null 。
> 9. offerFirst(Object o)   在此列表的前面插入指定的元素
> 10. getLast()   返回此列表的最后一个元素
> 11. pollLast()   检索并删除此列表的最后一个元素，如果此列表为空，则返回 null 。
> 12. peekLast()   获取但不移除此列表的最后元素；如果此列表为空，则返回 null。
> 13. offerLast(Object o)   在此列表的末尾插入指定的元素。
> 14. pop()   从此列表表示的堆栈中弹出一个元素。换言之，删除并返回此列表的第一个元素。
> 15. push()   将元素推入此列表所表示的堆栈。
> 16. peek()   获取但不移除此列表的头（第一个元素）。
> 17. poll()   获取并移除此列表的第一个元素 first 和 last 同上
> 18. offer()   将指定的元素添加为此列表的尾部（最后一个元素）

> ArrayList和LinkedList的比较：
>
> 1. ArrayList的底层是数组，LinkedList的底层的双向链表
> 2. ArrayList的查询效率更高
> 3. LinkedList的增删效率更好
>
> 两者的选用：增删多，选LinkedList；查询多选ArrayList

> Vector
>
> 1. 常用方法的方法就是Collection与List中的常用方法
>
> 2. 与ArrayList一样，底层都是数组
>
> 3. Vector线程安全（保证线程同步），ArrayList线程不安全（不保证线程同步）
>
> 4. Vector效率较低，ArrayList效率更高
>
>    
>
>    扩容：
>
>    1. ArrayList，如果使用有参构造函来创建，先根据指定容量创建数组，后续以1.5倍进行扩容；如果使用无参构造函数来创建，第一次添加元素，扩容到10，后续也是以1.5倍进行扩容。
>
>       **源码剖析**
>
>       ###### 以无参方式创建ArrayList集合
>
>       1. ```java
>          public class Test1 {
>              public static void main(String[] args) {
>                  //首先从无参的构造函数看起
>                  ArrayList<String> list = new ArrayList<>();
>                  list.add("6");
>              }
>          }
>          ```
>
>       2. ctrl点击后面的ArrayList<>();进入ArrayList类
>
>          ```java
>              public ArrayList() {
>                  //以无参构造函数创建ArrayList集合对象，将elementData赋值为有一个内容为空Object数组
>                  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
>              }
>          //elementData和DEFAULTCAPACITY_EMPTY_ELEMENTDATA在ArrayList中无参默认构造函数中的初始值
>          ```
>
>          ```java
>          transient Object[] elementData;
>          private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
>          ```
>
>       3. 进入add(E e)方法
>
>          ```java
>          public boolean add(E e) {
>              // 在添加数据前确保又能够操作的空间,且为扩容的条件，当size为elementDate的长度时，扩容条件满足
>              ensureCapacityInternal(size + 1);  
>              elementData[size++] = e;
>              return true;
>          }
>          
>          private int size;//ArrayList的私有属性，初始值为0
>          ```
>          
>       4. 进入ensureCapacityInternal(size + 1)
>
>          ```java
>          private void ensureCapacityInternal(int minCapacity) {
>              ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
>          }
>          ```
>       5. 进入calculateCapacity(elementData, minCapacity)
>
>          ```java
>          //minCaoacity：1  elementData：空的Object数组
>       private static int calculateCapacity(Object[] elementData, int minCapacity) {
>              //elementData之前被DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋过值，结果为ture
>              if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
>                  //DEFAULT_CAPACITY = 10 ,静态常量
>               return Math.max(DEFAULT_CAPACITY, minCapacity);
>              }
>           //minCapacity = 10
>              return minCapacity;
>          }
>          ```
>
>       6. 进入ensureExplicitCapacity(int minCapacity)
>
>          ```java
>          //minCapacity = 10
>          private void ensureExplicitCapacity(int minCapacity) {
>              	//记录从this对象创建以来，增删改查方法每执行一次，modCount都会++一次
>               	modCount++;
>              	//elementData.length = 0  elementData为Object空容器数组  minCapacity = 10
>               if (minCapacity - elementData.length > 0)
>                      //核心扩容方法
>                      grow(minCapacity);
>          }
>          ```
>
>       7. 进入grow(minCapacity)
>
>          ```java
>          private void grow(int minCapacity) {
>              // 记录旧的容器的大小
>              int oldCapacity = elementData.length;
>              // 预计要扩容到的容量，为旧容器的1.5倍
>              int newCapacity = oldCapacity + (oldCapacity >> 1);
>              //如果新的容器大小小于当前容器的大小，值被当前容器大小覆盖
>              if (newCapacity - minCapacity < 0)
>               newCapacity = minCapacity;
>              //private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
>           /*
>              数组有点特殊性，数组对象要额外存储数组元素长度在头部，少了这8个长度可能与此有关。
>          	尝试分配大于 MAX_ARRAY_SIZE 长度的数组会导致 OOM （换句话说，超过了该虚拟机的数组长度限制）。 ，一	般用不到，就不做过多解释
>          	*/
>              if (newCapacity - MAX_ARRAY_SIZE > 0)
>                  newCapacity = hugeCapacity(minCapacity);
>              // 给elementDate扩容并将之前的值继承，大小为newCapacity.length()
>              elementData = Arrays.copyOf(elementData, newCapacity);
>          ```
>          
>       8. 返回add()
>
>          ```java
>             //e 即传入的参数
>             public boolean add(E e) {
>                 ensureCapacityInternal(size + 1);
>                 //执行此条语句，默认从0下标开始被e值覆盖
>                 elementData[size++] = e;
>                 return true;
>             }
>          ```
>
>       ###### 有参方式创建ArrayList集合
>
>       1. ​	有参方式创建arrayList集合
>
>          ```java
>          public class Demo1 {
>              public static void main(String[] args) {
>                  ArrayList<String> arrayList = new ArrayList<>(20);
>                  arrayList.add("张三");
>              }
>          }
>          ```
>
>       2. 进入有参方法
>
>          ```java
>          //initialCapacity 传入的参数
>          public ArrayList(int initialCapacity) {
>              if (initialCapacity > 0) {
>                  //这里是new了一个Object对象数组，并非DEFAULTCAPACITY_EMPTY_ELEMENTDATA覆盖 
>                  this.elementData = new Object[initialCapacity];
>              } else if (initialCapacity == 0) {
>                  //EMPTY_ELEMENTDATA 一个内容为空Object数组
>                  this.elementData = EMPTY_ELEMENTDATA;
>              } else {
>                  throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity);
>              }
>          }
>          ```
>
>       3. 进入add(E e)方法
>
>          ```java
>          public boolean add(E e) {
>              //private int size;-------ArrayList的私有属性，初始值为0
>              ensureCapacityInternal(size + 1);
>              elementData[size++] = e;
>              return true;
>          }
>          ```
>
>       4. 进入ensureCapacityInternal(size + 1)
>
>          ```java
>          //minCapacity：1
>          private void ensureCapacityInternal(int minCapacity) {
>              ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
>          }
>          ```
>
>       5. 进入calculateCapacity(elementData, minCapacity)，有返回
>
>          ```java
>          //minCaoacity：1  elementData：空的Object数组 
>          private static int calculateCapacity(Object[] elementData, int minCapacity) {
>              //elementDate的地址是new的或被EMPTY_ELEMENTDATA这个空的Object[]覆盖,结果为false
>              if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
>                  return Math.max(DEFAULT_CAPACITY, minCapacity);
>              }
>              //mincapacity = 1
>              return minCapacity;
>          }
>          ```
>
>       6. 进入ensureExplicitCapacity(int minCapacity)
>
>          ```java
>          //minCapacity = 1
>          private void ensureExplicitCapacity(int minCapacity) {
>              //记录从this对象创建以来，增删改查方法每执行一次，modCount都会++一次
>              modCount++;
>              //elementData.length = 20，不进入grow()方法
>              if (minCapacity - elementData.length > 0)
>                  grow(minCapacity);
>          }
>          ```
>
>       7. 返回add()
>
>          ```java
>          public boolean add(E e) {
>              ensureCapacityInternal(size + 1);
>              //执行此条语句，默认从0下标开始被e值覆盖
>              elementData[size++] = e;
>              return true;
>          }
>          ```
>
>    2. Vector
>       1. 如果使用有参构造函`public Vector(int initialCapacity)`来创建，先根据指定容量创建数组，每次以2倍进行扩容；
>       2. 如果使用无参构造函数来创建，默认扩容到10，后续也是以2倍进行扩容
>       3. 如果使用有参构造函`public Vector(int initialCapacity, int capacityIncrement)`来创建，先根据指定容量创建数组，扩容时，根据指定的`capacityIncrement`来扩容
>
>       |           | 底层 | 出现的版本 | 线程问题、效率     | 扩容机制                                                 |
>       | --------- | ---- | ---------- | ------------------ | -------------------------------------------------------- |
>       | ArrayList | 数组 | jdk1.2     | 线程不同步，效率高 | 有参构造扩容1.5倍；无参构造，第一次扩容10，之后扩容1.5倍 |
>       | Vector    | 数组 | jdk1.0     | 线程同步，效率低   | 有参构造扩容2倍；无参构造，第一次扩容10，之后扩容2倍     |

### 四，Set :常用实现类：HashSet、TreeSet、LinkedHashSet

> 特点：
>
> 1. 无序（存取的顺序不一致），没有索引
> 2. 不允许有重复元素，最多只能有一个null
>
> 常用方法：和List一样，Set也是Collection的子接口，所以方法与Collection中的方法一样
>
> Set集合的遍历：可以使用迭代器，也可以使用增强for循环，但是不能使用普通for循环
>
> 1. itit:迭代器
>
>    ```java
>    while (iterator.hasNext()) {
>        Object next =  iterator.next();
>    }
>    ```
>
> 2. iter:增强for循环
>
>    ```java
>    for (String s : set) {
>        System.out.println(s);
>    }
>    ```

> HashSet的存储原理：
>
> 1. 存储一个元素时，先计算这个元素的hashCode值，确定它在集合中的位置，如果集合中没有一个元素与该元素的hashCode值相同，则直接存储。
> 2. 如果集合中已经有了与该元素相同的hashCode值的元素，会继续使用equals()来比较这两个元素，如果equals()的返回结果为false，则存储，如果equals()的返回结果为true，则不存储。
> 3. HashSet的底层是HashMap，HashMap的底层是数组+链表
> 4. 第一次添加元素时，数组扩容到16，加载因子0.75，`临界值=加载因子*容量`
> 5. 再添加元素时，当到达了临界值时，数组会扩容到原来的2倍就是32，临界值就是32的0.75倍是24
> 6. 从Java8开始，如果一条链表的个数达到8个，并且整个容器存储的元素个数到达64个时，链表会自动树形化，转换成红黑树

> TreeSet：
>
> 1. TreeSet是能够实现自动排序的集合,将整数、小数、字符串等不同类型的数据分别存储进各自的TreeSet后，TreeSet会将它们根据字典顺序进行排序。
>
> 2. 使用TreeSet实现自定义类型的属性排序：
>
>   1. 实现Comparable接口
>
>   2. 重写compareTo()方法
>
>   ```java
>    // 年龄升序，年龄相同，按姓名升序9
>   @Override
>    public int compareTo(Emp o) {
>        return o.age == this.age ?  this.name.compareTo(o.name) : this.age - o.age;
>    }
>   ```
>

#### TreeSet对象丢失问题的解决方法

> 一如下代码为例
>
> ```JAVA
>package treeMap;
> 
>import java.util.Collections;
> import java.util.Set;
>import java.util.TreeSet;
> 
>public class Demo1 {
> 
>     public static void main(String[] args) {
>         Set<Stu> stuSet = new TreeSet<>();
>         Stu stu1 = new Stu(1, "zs", 18);
>         Stu stu2 = new Stu(2, "ls", 28);
>         Stu stu3 = new Stu(3, "ws", 18);
>         Stu stu4 = new Stu(4, "zl", 8);
>        Collections.addAll(stuSet, stu1, stu2, stu3, stu4);
>         for (Stu stu : stuSet) {
>            System.out.println(stu);
>         }
>    }
> }
> 
> 
> class Stu implements Comparable {
>     Integer id;
>     String name;
>     Integer age;
> 
>     public Stu() {
>     }
> 
>     public Stu(Integer id, String name, Integer age) {
>         this.id = id;
>         this.name = name;
>         this.age = age;
>     }
> 
>     @Override
>     public int compareTo(Object o) {
>         Stu stu = (Stu) o;
>         return this.age - stu.age;
>     }
> 
>     @Override
>     public String toString() {
>         return "Stu{" +
>                 "id=" + id +
>                 ", name='" + name + '\'' +
>                 ", age=" + age +
>                 '}';
>     }
> 
>     public Integer getId() {
>         return id;
>     }
> 
>     public void setId(Integer id) {
>         this.id = id;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public Integer getAge() {
>         return age;
>     }
> 
>     public void setAge(Integer age) {
>         this.age = age;
>     }
> }
> ```
> 
> 输出结果
> 
> ```tex
> Stu{id=4, name='zl', age=8}
> Stu{id=1, name='zs', age=18}
> Stu{id=2, name='ls', age=28}
> ```
> 
> 可以发现在我们存进去的四个对象，少了一个name="ws"
> 
> 源码剖析：
> 
> 1. 进入TreeSet的add();方法
> 
>    ```java
>    public boolean add(E e) {
>        return m.put(e, PRESENT)==null;
>    }
>    ```
>
>    此方法中的m
>
>    ```java
>    private transient NavigableMap<E,Object> m;
>    // Dummy value to associate with an Object in the backing Map
>    private static final Object PRESENT = new Object();
>    
>   TreeSet(NavigableMap<E,Object> m) {
>        this.m = m;
>   }
>    
>   public TreeSet() {
>        this(new TreeMap<E,Object>());
>   }
>    ```
>    
>    可以发现在创建TreeSet对象时，其无参构造函数调用了本身的有参构造函数，并将TreeMap赋值给本身的NavigableMap<E,Object> m，所以m本质上是一个TreeMap，也就是说TreeSet是以TreeMap为容器，其添加数据的方式遵循map集合添加元素的规则
>    
> 2. TreeMap是双列集合，不允许键重复，且会对键进行排序，当键是自定义对象时，需要实现Comparator接口，并实现比较方法compare(T o1,T o2)；
>
> 3. 进入TreeMap的put()方法
>
>    ```java
>    public V put(K key, V value) {
>        Entry<K,V> t = root;
>        if (t == null) {
>            compare(key, key); // type (and po
>            root = new Entry<>(key, value, nul
>            size = 1;
>            modCount++;
>            return null;
>        }
>        int cmp;
>        Entry<K,V> parent;
>        // split comparator and comparable pat
>        Comparator<? super K> cpr = comparator;//这里要注意，添加元素的重点
>        if (cpr != null) {//如果不为空，进入方法
>            do {
>                parent = t;
>                cmp = cpr.compare(key, t.key);//调用自定义方法所返回的值
>                if (cmp < 0)
>                    t = t.left;
>                else if (cmp > 0)
>                    t = t.right;
>                else
>                    return t.setValue(value);
>            } while (t != null);
>        }
>        else {
>            if (key == null)
>                throw new NullPointerException
>            @SuppressWarnings("unchecked")
>               Comparable<? super K> k = (Com
>            do {
>               parent = t;
>                cmp = k.compareTo(t.key);//Comparable比较器的比较方法
>               if (cmp < 0)
>                    t = t.left;
>               else if (cmp > 0)
>                    t = t.right;
>                else
>                    return t.setValue(value);
>            } while (t != null);
>        }
>        Entry<K,V> e = new Entry<>(key, value,
>        if (cmp < 0)
>            parent.left = e;
>        else
>            parent.right = e;
>        fixAfterInsertion(e);
>        size++;
>        modCount++;
>        return null;
>    }
>    ```
> 
>    ```java
>    private final Comparator<? super K> comparator;
>    
>    //其无参构造函数
>    public TreeMap() {
>            comparator = null;
>    }
>    ```
> 
>    从源码中可以看到，put第一个值时，直接放入TreeMap中。第二个开始就会调用比较器compare方法。比较结果小于0就将当前的数据放在节点的左侧；如果大于0，就放在节点的右侧；等于0时，也就是比较的结果就会覆盖当前值。
> 
> 4. 我的自定义对象重写的方法只对age做了比较，当返回值为0时，之前的值被覆盖，所以对象并不是丢失，而是覆盖了前一个返回值为0的对象
> 
> 5. 所以接下来的操作即是对自定义对象重写的比较方法完善规则即可；

> LinkedHashSet：
>
> 1. LinkedHashSet继承了HashSet	
>
> 2. LinkedHashSet的底层是LinkedHashMap，LinkedHashMap的底层数组+双向链表
>
> 3. LinkedHashSet它是有序的(默认是存储顺序)
>
> 4. LinkedHashSet中的LinkedHashMap有一个head和一个tail用于保存添加时首元素和尾元素对象
>
> 5. 在LinkedHashMap中添加的每一个元素对象，都有before指向上一个节点，after指向下一个节点
>
>    ![](照片\屏幕截图 2023-12-11 193227.png)

### 五，Mapction不同的是Map中的每一个元素都需要由两个数据组成，这两个数据分别是`键`和`值`，这个整体称为`键值对`，`键值对`的关系称为一一对应的`映射关系`

> 特点：
>
> 1. 键必须唯一的，值可以重复
>2. `键值对`的关系称为一一对应的`映射关系`
> 
> 常用方法：
>
> 1. put(Object k，Object v)  //添加键值对
>2. remove(Object k)  //删除指定键的键值对
> 3. remove(Object k，Object v) //删除指定键值对，有就删除返回true，没有就不删除返回false
> 4. replace(Object k，Object v) //修改指定键的值
> 5. replace(Object k，Object oldValue，Object newValue) //(返回boolean值......)
> 6. get(Object k) //获取指定键的值
> 7. getOrDefault(Object k，Object defaultValue)：如果k存在，则获取这个k所对应的v，如果k不存在，则返回defaultValue
> 8. containsKey(Object k)  //判断是否有这个键
> 9. containsValue(Object v)  //判断是否有这个value
> 10. clear()  //清空集合
> 11. isEmpyt()  //判断集合是否null
> 12. size()  //返回集合大小

> Map的遍历
>
> Map不能使用普通for循环遍历，也不能使用增强for循环遍历，所以也不能使用迭代器遍历
>
> 1. **values()方法：拿到全部的Value**返回Map集合中所有键组成的Set集合
>
>    ```java
>    Map<String,Integer> map = new HashMap();
>    map.put("zs",1);
>    map.put("ls",11);
>    map.put("ww",12);
>    
>    // 返回Map集合中所有键组成的Set集合
>    Set<String> set = map.keySet();
>    System.out.println("set："+set);
>    
>    for(String s : set){
>        System.out.println(s + "=" + map.get(s));
>    }
>    
>    Iterator<String> it = set.iterator();
>    while(it.hasNext()){
>        String key = it.next();
>        System.out.println(key + "--"+ map.get(key));
>    }
>    ```
>    
> 2. **entrySet()方法** **：拿到全部的键值对**---------返回的是一个Set<Map.Entry<K,V>>
>
>    ```java
>    HashMap<String,Integer> map = new HashMap();
>    map.put("a",1);
>    map.put("b",2);
>    map.put("c",3);
>    map.put("d",4);
>    
>    Set<Map.Entry<String,Integer>> set = map.entrySet();
>    Iterator<Map.Entry<String,Integer>> it = set.iterator();
>    while(it.hasNext()){
>        Map.Entry<String,Integer> en = it.next();
>        System.out.println(en.getKey()+"--"+en.getValue());
>    }
>    
>    for(Map.Entry<String,Integer> en : set){
>        System.out.println(en.getKey()+"---"+en.getValue());
>    }
>    ```
>    
> 3. **values()方法：拿到全部的Value**
>
>    ```java
>    HashMap<String, Integer> map1 = new HashMap<>();
>    map1.put("小明", 1);
>    map1.put("小红", 2);
>    map1.put("小张", 3);
>    
>    //for-each + keySet()遍历key
>    for (String key : map1.keySet()) { //遍历key
>        System.out.println("key = " + key);
>    }
>    //for-each + values()遍历value
>    for (Integer value : map1.values()) { //遍历value
>        System.out.println("value = " + value);
>    }
>    ```
>
>    

> HashMap：底层是数组+链表（红黑树）
>
> TreeMap：底层是红黑树，它可以实现自动排序，自动排序的是键；如果存储在TreeMap中的自定义类型的属性要进行排序，该类必须实现Comparable接口，重写compareTo()方法，将该类型作为Map中的键的类型
>
> LinkedHashMap：底层是数组+双向链表，可以保证存取顺序一致

> Properties：属性集，它继承了HashTable，HashTable实现了Map接口，所以Properties本质上也是一个Map，因此它具有Map中的所有方法。
>
> 在Properties中定义了它的一些特有方法，专门用于读取配置文件中的内容，
>
> 配置文件的书写：
>
> 1. 每一段数据必须与键值对的形式出现
> 2. 每一段数据必须独占一行
> 3. 键值对之间可以用`:、=、空格`分隔
>
> Properties使用的注意点：
>
> 1. Properties不能指定泛型，键和值都是String类型的
> 2. 一般用于读取配置文件
>
> 常用方法：
>
> 1. load(Reader r)：加载指定位置的文件中的内容到Properties中
> 2. load(InputStream is)
> 3. getProperties(String key)
> 4. getProperties(String key，String defaultValue)

### 六，Collections

> 集合工具类型，此类包含对集合进行操作或返回集合的静态方法。
>
> 常用方法：
>
> 1. addAll(Collection c，Object...o)  //将所有指定的元素添加到指定的集合中。
> 2. binarySearch(List l，Object o)  //使用二分法查找，以获得指定对象在List中的索引，前提是集合已经排序
> 3. sort(List l)  //对List里的元素根据自然升序排序
> 4. sort(List l，Comparator c)  //按照自定义比较器排列顺序
> 5. shuffle(List l)  //打乱集合元素位置
> 6. fill(List l，Object o)  //对List里的元素根据自然升序排序
> 7. swap(List l，int i，int j)  //此集合中的两个元素交换位置
> 8. replaceAll(List l，Object oldV ，Object newV)  //将集合中所有的oldV元素替换成newV元素
> 9. reverse()  //倒序集合中的元素
