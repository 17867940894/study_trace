### 一，异常的体系结构

> Java中程序在运行期间发生的不正常的情况就是异常，系统将各种异常封装成了一种数据类型，`Exception`异常类。
>
> `Throwable` 类是 Java 语言中所有错误和异常的超类。
>
> `Exception` 类及其子类是 `Throwable` 的一种形式，它指出了合理的应用程序想要捕获的条件。 Exception的直接子类都被称为编译时异常，另一子类运行时异常，可以处理也可以不处理
>
> `Error` 是 `Throwable` 的子类，用于指示合理的应用程序不应该试图捕获的严重问题，Error异常一旦发生Jvm停止运行
>
> 注：
>
> 1. 只有`Throwable`及其子类对象，才能被JVM或者关键字`throw`抛出；只有`Throwable`及其子类才能作为`catch`的参数
> 2. Error和Exception的对象是在异常情况的上下文中由系统新近创建的，因此包含了相关的信息。

### 二，异常的处理方式 throws

> 关键字：`throws`
>
> 格式：
>
> ```java
> public 返回类型 方法名(参数列表) throws 异常类 {
>     方法体
> }
> ```
>
> 作用：抛出异常，将异常抛给当前方法的调用者；告知调用者当前方法存在异常
>
> 问：为什么抛出异常并没有实际的解决异常还要进行抛出？
>
> 答：因为对于同一个异常来说，处理的方式可以各不相同，所以不能在定义异常的方法中处理，而应该调用方法时进行处理，由调用者决定如何处理。
>
> 注：
>
> 1. 抛出的异常类必须是所发生的异常或者它的父类
> 2. 如果父类方法没有抛出异常，子类重写也不能抛出
> 3. 如果抛出的异常是`RuntimeException`及其子类，那么调用者可以不作处理；如果不是，必须处理

### 三，异常的处理方式 try-catch

> 关键字：`try、catch、finally`
>
> 格式1：
>
> ```java
> try{
>     
> }catch(异常类 对象名){
>     
> }
> ```
>
> 格式2：
>
> ```java
> try{
>     
> }finally{
>     
> }
> ```
>
> 格式3：
>
> ```java
> try{
>     
> }catch(异常类 对象名){
>     
> }finally{
>     
> }
> ```
>
> 格式说明：
>
> 1. try代码块中的是可能发生异常需要进行检测的代码
> 2. try代码块中一旦发生了异常就会立即进入catch代码块，没有发生异常就不会进入catch，如果没有catch代码块，则不进入；如果发生了异常，却没有catch可进入，就意味着异常没有被捕获，没有被处理掉
> 3. finally代码块中的代码一定会执行，通常用于释放资源
>
> 注：catch子句的异常类型必须是try中发生的异常或者它的父类

> 多个异常的处理方式：
>
> 1. 多个异常一次处理
>
>    ```java
>    try{
>        int[] arr = {0,1,2,3};
>        Random r = new Random();
>        int index = r.nextInt(5);//[0,4]
>        System.out.println(index);
>        System.out.println(10 / arr[index]);
>    }catch (Exception e){
>        System.out.println("出错了");
>    }
>    // 好处就是方便，弊端就是无法明确发生的是具体哪种异常
>    ```
>
> 2. 多个异常分别处理
>
>    ```java
>    try{
>        int[] arr = {0,1,2,3};
>        Random r = new Random();
>        int index = r.nextInt(5);//[0,4]
>        System.out.println(index);
>        System.out.println(10 / arr[index]);
>    }catch (ArrayIndexOutOfBoundsException e){
>        System.out.println("越界了");
>    }catch (ArithmeticException e){
>        System.out.println("除0了");
>    }
>    ```
>
> 注：
>
> 1. 如果多个catch的异常类型没有继承关系，那么它们的顺序是任意的
>
> 2. 如果多个catch的异常类型有继承关系，那么父类异常必须在子类异常的后面
>
> 3. 可以在多个catch后添加Exception来处理没有捕获到的异常
>
>    ```java
>    try{
>        int[] arr = {0,1,2,3};
>        Random r = new Random();
>        int index = r.nextInt(5);//[0,4]
>        System.out.println(index);
>        if(index > 0 && index <= arr.length - 1){
>            System.out.println(10 / arr[index]);
>        }else{
>            System.out.println("");
>        }
>    }catch (ArithmeticException e){
>        System.out.println("除0了");
>    }catch (ArrayIndexOutOfBoundsException e){
>        System.out.println("越界了");
>    }catch (Exception e){
>        System.out.println("未知异常");
>    }
>    ```

#### finally的使用

> ```java
>FileOutputStream fos = null;
> try{
>  fos = new FileOutputStream("C:\\Users\\86151\\Desktop\\a.txt");
>  fos.write(97);
>     fos.close();
>    }catch (FileNotFoundException e){
>     System.out.println("文件找不到");
> }catch (IOException e){
>     System.out.println("写入动作发生异常");
> }finally {
>     try {
>      if(fos != null){
>             fos.close();
>         }
>     }catch (IOException e){
>    
>     }
> }
>    ```
> 
> 注：无论try、catch中返回的是什么，只要finally中有返回，返回结果一定是finally中的

#### 异常处理的语法规则： 

>- 第一、try语句不能单独存在，可以和catch、finally组成 try...catch...finally、 try...catch、try...finally三种结构，catch语句可以有一个或多个，finally语句最多一个， try、catch、finally这三个关键字均不能单独使用。 
>- 第二、try、catch、finally三个代码块中变量的`作用域分别独立`而不能相互访问。 第三、多个catch块时候，Java虚拟机会匹配其中一个异常类或其子类，就执行这个 catch块，而不会再执行别的catch块。

#### 异常对象的常用方法

>1、getMessage()：获取异常的详细信息。
>2、printStackTrace()：打印异常的堆栈跟踪信息。
>3、getCause()：获取导致异常的原因。
>4、getLocalizedMessage()：获取异常的本地化信息。
>5、toString()：获取异常的字符串表示形式。

### 四，异常的处理方式 throw

> 关键字：`throws`，使用在定义方法时的方法头上，用于抛出异常类型，告知调用者当前的方法存在何种异常
>
> 关键字：`throw`，使用在方法体的语句中，用于抛出异常对象
>
> 注：
>
> 1. 一旦通过`throw`关键字抛出了异常对象，就意味着程序运行到这句话时就已经发生了指定的异常，发生异常成程序就终止，因为`throw`语句后不能再写语句
>
> ```java
> public static void myCopy(int[] a ,int index1 ,int[] b ,int index2 ,int len){
>     if(a == null || b == null){
>         throw new NullPointerException();
>     }
>     if(index1 > a.length - 1 || index2 > b.length - 1 || index1 + len > a.length || index2 + len > b.length){
>         throw new ArrayIndexOutOfBoundsException();
>     }
>     for(int i = index1 ; i < index1 + len ;i++){
>         b[index2++] = a[i];
>     }
> }
> ```

### 五，自定义异常类

> 将项目中某些情况的发生可以视为一种异常，这种异常系统并没有定义，只有当前工程中才有这种异常。
>
> 定义的步骤：
>
> 1. 定义类继承Exception或者RuntimeException
> 2. 定义无参构造函数和一个重载的参数是String的构造函数
>
> 方法覆盖（重写）规则
>
> 1.方法签名必须相同，方法名与参数列表就是方法签名
>
> 2.方法的返回值类型可以相同，子类方法的返回值类型可以是父类方法返回值类型的子类型
>
> 3.字类方法的访问权限可以更宽泛（更大）
>
>     1.如果父类方法使用 public 修饰，子类方法只能是 public 修饰
>     
>     2.如果父类方法使用 protected 修饰，子类方法可以是 protected/public 修饰
>
> 4.子类方法的异常要比父类方法的异常更小
>
>     1.如果父类方法没有抛出异常，子类重写后也不能抛出异常
>     
>     2.如果父类方法抛出了异常，子类方法可以抛出相同的异常，也可以抛出父类异常的子异常，也可以不抛出异常
>     注：如果父类方法没有抛出异常，那么子类重写只能抛出`RuntimeException`及其子类，不能抛出其他异常
>
> 





























