### 五，多态

#### 5.1 概念

> 前提：必须有继承或者实现的关系
>
> 一个子类就是一个父类
>
> 多态的概念：父类的引用变量指向子类对象（子类对象赋值给父类的引用变量）
>
> 代码中的体现：父类Emp、子类Programmer，Emp p = new Programmer();
>
> `父类 引用变量名 = new 子类();`

#### 5.2 多态下，调用成员变量和成员方法的特点

> 调用成员变量的特点：
>
> 编译时期：如果父类没有这个变量，则编译失败；父类中有这个变量才能编译通过
>
> 运行时期：访问的是父类中的变量
>
> 小结：编译运行都看左边

> 调用成员方法的特点：
>
> 编译时期：如果父类没这个方法，则编译失败；父类中有这个方法才能编译通过
>
> 运行时期：访问的子类中的方法
>
> 小结：编译看左边，运行看右边

> 弊端：多态下，不能访问子类的特有内容

#### 5.3 多态的应用

> 场景1：
>
> 如果一个方法的形参是引用数据类型，那么实参可以是该类型或者是该类型的任何一个子类或者实现类对象
>
> ```java
> ArrayList<Integer> list = new ArrayList<>();
> list.add(1);
> list.add(2);
> list.add(3);
> list.add(4);
> list.add(5);
> System.out.println(list);
>
> System.out.println("------------------------");
>
> LinkedList<Integer> list2 = new LinkedList<>();
> list2.add(11);
> list2.add(22);
> list2.add(33);
> list2.add(44);
> list2.add(55);
> System.out.println(list2);
>
> Collections.shuffle(list);
> Collections.shuffle(list2);
> ```
>
> Collections中的shuffle方法用于对集合进行打乱，shuffle方法的形参是List，List是一个接口，因此实参可以是List接口的任何一个实现类的对象

> 场景2：
>
> 如果一个方法的返回类型是引用数据类型，那么返回的结果可以是该类型或者是该类型的任何一个子类或者实现类对象

#### 5.4 多态的转型问题

> 向上转型
>
> 多态本身就是向上转型，将子类对象赋值给父类的引用变量
>
> 弊端：多态下无法访问子类的特有内容

> 向下转型
>
> 多态下无法访问子类的特有内容，想要访问到子类的特有内容，需要向下转型
>
> 格式：
>
> ```java
> Fu f = new Zi();
> Zi z = (Zi)f;
> ```
>
> 注：如果向下转型的目标类型与多态下的类型不匹配，会发生`ClassCastException`类型转换异常
>
> 解决办法：`instanceof`
>
> 用法：
>
> ```java
> 对象 instanceof 类型
> ```
>
> 作用：判断该对象是否属于指定类型，返回布尔值

> `instanceof`的使用细节：
>
> 1. 如果对象与指定类型不相同并且没有继承关系，则编译失败
> 2. 在没有多态的情况下，判断对象是否属于创建时指定的类型，是没有意义的，因为结果永远为true
> 3. 如果判断一个子类对象是否属于它的父类，也是没意义的，因为结果永远为true
> 4. 只有在多态的情况下，判断引用变量是否是多态时父类的子类时才有意义
>
> `instanceof`使用的总结：在多态下，判断引用变量是否是多态时父类的子类